---
title: "Analyse descriptive des variables"
output:
  html_document:
    df_print: paged
    toc: yes
  html_notebook:
    toc: yes
    toc_float:
      collapsed: no
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.width = 10)

# Libs
library(readr)
library(plyr)
library(tidyverse)
library(DT)
library(desctable)
library(cowplot)
library(corrplot)
library(RColorBrewer)
library(NbClust)
library(factoextra)
library(dendextend)


# Importation des données ####
wdbc <- read_csv("../data/wdbc.data", col_names = FALSE)
wdbc$X2<- as.factor(wdbc$X2)

# Nom des colonnes
colnames <- c("radius", "texture", "perimeter", "area", "smoothness", "compactness", "concavity",  "concave_points", "symmetry",  "fractal_dimension")
variables <- gsub("_", " ", colnames) %>% str_to_title
colnames_mean <- paste0(colnames, "_mean")
colnames_se <- paste0(colnames, "_se")
colnames_worst <- paste0(colnames, "_worst")
colnames_all <- c("id", "diagnosis", colnames_mean, colnames_se, colnames_worst)
colnames(wdbc) <- colnames_all

## Données sans id ni diagnosis
wdbc_blind <- wdbc[c(-1, -2)]
## Diagnosis en numérique (M = 1, B = 2)
wdbc2 <- wdbc
wdbc2$diagnosis <- plyr::revalue(wdbc$diagnosis, c("M"="1", "B"="2")) %>% as.numeric
## Application de scale
wdbc_scaled <- wdbc_blind %>% apply(2, FUN=scale) %>% as.data.frame
```

## Description des variables

### Diagnostic

C'est une variable catégorielle binaire qui renseigne sur le diagnostic associé à l'échantillon. Elle prend soit la valeur "B" pour désigner une tumeur bénine, soit la valeur "M" pour une tumeur maligne.

```{r graph_diagnosis}
ggplot(data = wdbc) +
  aes(x = diagnosis, fill = diagnosis) +
  geom_bar(width = 0.5) +
  labs(title = 'Nombre de tumeurs en fonction du diagnostic',
    x = 'Diagnostic', y = 'Nombre') +
  annotate("text", c(1, 2), c(375, 230), label = c("357 (62,74 %)", "212 (37,26 %)")) +
  theme_minimal() +
  theme(legend.position = 'none')
```

Ainsi, on voit que deux tiers des tumeurs sont bénignes.

### Taille du noyau

Trois variables numériques continues renseignent sur la **taille** du noyau des cellules : le rayon (radius), le périmètre (perimeter) et l'aire (area). Elles sont corrélées entre elles et liées par des relations mathématiques.

```{r functions_desc_var, include=FALSE}
# Construit un graphique pour représenter une variable (boxplot + nuage de point) en fonction de la catégorie diagnostique
show.var <- function(variable, titre = "", abscisses = "", limites = NA) {
  ggplot(data = wdbc) +
    aes_string(x = "diagnosis", y = variable, fill = "diagnosis") +
    geom_boxplot() +
    geom_jitter(width = 0.1, alpha = 0.4) +
    theme_minimal() +
    theme(legend.position = 'none') +
    scale_y_continuous(limits = limites) +
    labs(x = "Diagnostic", title = titre, y = abscisses) +
    coord_flip()
}

# Construit une grille avec, pour chaque variable 3 graphiques : moyenne, erreur standard et worst.
# Les limites sont les mêmes, automatiquement calculées et alignées pour les graphiques de la moyenne et de worst pour permettre des les comparer
graphs.grid <- function(variable, variable.title, m = F) {
  # Calcul des limites pour les graphiques de moyenne et de pire
  limites = c(min(wdbc[,paste0(variable, "_mean")])*0.8, max(wdbc[,paste0(variable, "_worst")])*1.1)
  # Calcul des limites pour le graphique de l'erreur standard
  limites_se = c(0, max(wdbc[,paste0(variable, "_se")]))
  # Grille
  plot_grid(align = "hv",
    show.var(paste0(variable, "_mean"),
             str_to_sentence(paste0(variable.title, ifelse(m == T, " moyen", " moyenne"),' des noyaux')),
             str_to_sentence(paste0(variable.title, ifelse(m == T, " moyen", " moyenne"))),
             limites),
    show.var(paste0(variable, "_se"),
             paste0('Erreur standard ',
ifelse(m == T, "du ", ifelse(variable.title == "aire", "de l'", "de la ")), variable.title, ifelse(m == T, " moyen ", " moyenne "),'
des noyaux'),
             'Erreur standard',
             limites_se),
    show.var(paste0(variable, "_worst"),
             paste0('Pire ', variable.title,' des noyaux'),
             paste0('Pire ', variable.title),
             limites))
}
```

#### Rayon

```{r radius_graphs, warning=FALSE, message=FALSE}
graphs.grid("radius", "rayon", T)
```

#### Périmètre

```{r perimeter_graphs, warning=FALSE, message=FALSE}
graphs.grid("perimeter", "périmètre", T)
```

#### Aire

```{r area_graphs, warning=FALSE, message=FALSE}
graphs.grid("area", "aire")
```

### Aspect

L'aspect du noyau est raporté par deux variables numériques continues : la compacité et la texture. Comme pour la taille du  noyau, les valeurs pour les tumeurs malignes sont plus élevées que pour les bénignes.

#### Compactness

La compacité est calculée par la formule suivante : $\frac{perimeter^2}{area} - 1$

```{r compactness_graphs, warning=FALSE, message=FALSE}
graphs.grid("compactness", "compacité")
```

#### Texture

La texture du noyau est calculée à partie de l'ecart-type des valeurs des échelles de gris.

```{r texture_graphs, warning=FALSE, message=FALSE}
graphs.grid("texture", "texture")
```

### Forme du noyau

Cinq variables numériques continues ont été mesurées pour rendre compte de la forme du noyau. On voit que la différence entre les cellules malignes et bénignes est la plus marquée pour les variables `concavity` et `concave points`. Les cellules tumorales malignes ont donc un noyau avec des contours plus concaves par rapport aux cellules bénines. La dimension fractale par contre n'est pas différente entre les deux types de cellules.

#### Smoothness

```{r smoothness_graphs, warning=FALSE, message=FALSE}
graphs.grid("smoothness", "régularité")
```

#### Concavity

```{r concavity_graphs, warning=FALSE, message=FALSE}
graphs.grid("concavity", "concavité")
```

#### Concave points

```{r concave_points_graphs, warning=FALSE, message=FALSE}
graphs.grid("concave_points", "nombre de points concaves", T)
```

#### Symmetry

```{r symmetry_graphs, warning=FALSE, message=FALSE}
graphs.grid("symmetry", "symétrie")
```

#### Fractal dimension

La dimension fractale est une variable numérique continue. Elle renseigne sur l'irrégularité des contours du noyau des cellules.

```{r fractal_dimension_graphs, warning=FALSE, message=FALSE}
graphs.grid("fractal_dimension", "dimension fractale")
```

## Variables pertimentes

La figure ci dessous montre les coefficients de corrélation enntre le diagnostic et les autres variables.

```{r cor_diag}
cor_diag <- cor(wdbc2[,2], wdbc2[,c(2:32)])

corrplot(cor_diag, method = "number", diag = F, cl.pos = F, addCoefasPercent = T, tl.col = 'black')

cor_diag %>% t() %>% as.data.frame %>%
  rownames_to_column %>%
  dplyr::filter(diagnosis>0.5) %>%
  arrange(desc(diagnosis)) %>%
  select(rowname) %>%
  unlist %>% as.vector -> var_pert

var_pert <- var_pert[c(-1, -5, -7, -8, -9, -14, -16)]
```


Pour sélectionner les variables pertinentes, nous avons choisi de ne garder que celles qui sont corrélées à plus de 50% avec le diagnostic. Comme le périmètre, l'aire et le rayon sont liés entre eux, nous n'avons gardé que le périmètre, qui est la variable la plus corrélée des trois avec le diagnostic. On obtient alors `r length(var_pert)` variables pertinentes qui sont, de la plus corrélée à la moins corrélée : `r var_pert`.

Le graphique ci dessous montre le nuage de point obtenu quand on croise les deux variables les plus corrélées :

```{r graph_cor_diag}
ggplot(data = wdbc) +
  aes_string(x = var_pert[1], y = var_pert[2], color = "diagnosis") +
  geom_point() +
  labs(title = 'Variables les plus corrélées aux diagnostic') +
  scale_color_discrete(name = "Diagnostic") +
  theme_minimal()
```
