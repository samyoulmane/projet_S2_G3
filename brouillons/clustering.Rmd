---
title: "Analyse d’un jeu de données"
author: "Guillaume LA & Samy OULMANE"
date: "2018/2019"
output:
  html_document:
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
subtitle: "Projet du 2e semestre - DFGSM3 - UE11 parcours d'informatique biomédicale"
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.width = 10)

# Libs
library(plyr)
library(readr)
library(tidyverse)
library(DT)
library(desctable)
library(cowplot)
library(corrplot)
library(RColorBrewer)
library(NbClust)
library(factoextra)
library(dendextend)

# Importation des données ####
wdbc <- read_csv("../data/wdbc.data", col_names = FALSE)

# Nom des colonnes
colnames <- c("radius", "texture", "perimeter", "area", "smoothness", "compactness", "concavity",  "concave_points", "symmetry",  "fractal_dimension")
variables <- gsub("_", " ", colnames) %>% str_to_title
colnames_mean <- paste0(colnames, "_mean")
colnames_se <- paste0(colnames, "_se")
colnames_worst <- paste0(colnames, "_worst")
colnames(wdbc) <- c("id", "diagnosis", colnames_mean, colnames_se, colnames_worst)

## Diagnosis en numérique (B=1, M=2)
wdbc2 <- wdbc
wdbc2$diagnosis <- revalue(wdbc$diagnosis, c("B"="1", "M"="2")) %>% as.numeric

## Données sans id ni diagnosis
wdbc_blind <- wdbc[c(-1, -2)]
## Application de scale
wdbc_scaled <- wdbc_blind %>% apply(2, FUN=scale) %>% as.data.frame
```

***

# Clustering

La deuxième étape de notre analyse consistera à utiliser des algorithmes de clustering pour identifier des groupes au sein des données.    
Nous utiliserons trois algorithmes de clustering :

- k-means clustering
- clustering hiérarchique
- EM 

La démarche sera la même à chaque fois : on commencera d'abord avec les données "brutes" c'est-à-dire en utilisant *toutes* les variables et ensuite en utilisant seulement quelques variables sélectionnées. Notre but étant de pouvoir consituer des clusters proches des catégories diagnostiques (bénin/malin).

## K-means

```{r}
# Construction du modèle en imposant deux clusters
model_km <- kmeans(wdbc_scaled, 2)

# Visualisation des clusters
fviz_cluster(data = wdbc_scaled, model_km)

# Vérification par rapport au diagnostic
wdbc2 <- wdbc2 %>% mutate(clusters_km = model_km$cluster)
(verif_table_km <- table(wdbc$diagnosis, wdbc2$clusters_km))
erreur_km <- (min(verif_table_km[,1])+min(verif_table_km[,2]))/5.69
```

L'algorithme produit deux clusters de tailles `r model_km$size[1]` et `r model_km$size[2]` avec une erreur de `r round(erreur_km, 2)` % puisque `r min(verif_table_km[,1])+min(verif_table_km[,2])` individus sont mal groupés.

L'algorithme arrive néanmoins à identifier deux groupes qui sont proches des catégories diagnostiques. Dans le cluster où on trouve une majorité de cellules bénignes, on retrouve une minorité de cellules malignes, et vice-versa.
