---
title: "Analyse d’un jeu de données"
author: "Guillaume LA & Samy OULMANE"
date: "2018/2019"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
  html_notebook: default
subtitle: "Projet du 2e semestre - DFGSM3 - UE11 parcours d'informatique biomédicale"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.width = 10)

# Libs
library(readr)
library(tidyverse)
library(DT)
library(desctable)
library(cowplot)
library(corrplot)
library(RColorBrewer)
library(plyr)
library(NbClust)
library(factoextra)
# Importation des données
wdbc <- read_csv("data/wdbc.data", col_names = FALSE)

# Nom des colonnes
colnames <- c("radius", "texture", "perimeter", "area", "smoothness", "compactness", "concavity",  "concave_points", "symmetry",  "fractal_dimension")
variables <- gsub("_", " ", colnames) %>% str_to_title
colnames_mean <- paste0(colnames, "_mean")
colnames_se <- paste0(colnames, "_se")
colnames_worst <- paste0(colnames, "_worst")
colnames_all <- c("id", "diagnosis", colnames_mean, colnames_se, colnames_worst)
colnames(wdbc) <- colnames_all


# Diagnostic en numérique (0=B, 1=M)
wdbc2 <- wdbc
wdbc2$diagnosis[wdbc2$diagnosis=="B"] <- 0
wdbc2$diagnosis[wdbc2$diagnosis=="M"] <- 1
wdbc2[2] <- wdbc2[2] %>% unlist %>% as.numeric
# Découpage selon mean, worst, se, en gardant diagnostic, en éliminant id
wdbc2_mean <- wdbc2[,2:12]
wdbc2_worst <- wdbc2[,c(2,23:32)]
wdbc2_se <- wdbc2[, c(2, 13:22)]

```

***

# Analyse descriptive

## Description de la population

Le jeu de données est constitué de `r nrow(wdbc)` entrées. Chacune de ces entrées correspond à une personne atteinte d'un cancer du sein chez qui une biopsie de la tumeur a été effectuée. Les noyaux des cellules tumorales on ensuite été énalysé et les données recueillies sont présentées dans le tableau ci-dessous. Pour chaque variable, on a **la moyenne** (mean), **l'erreur standard** (SE) et **la "pire"" valeur** (worst, c'est-à-dire la moyenne des trois plus grandes valeurs de la variable).

```{r table_desc_1}

sketch = htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(rowspan = 2, 'ID'),
      th(rowspan = 2, 'Diagnosis'),
      th(colspan = 3, 'Radius'),
      th(colspan = 3, 'Texture'),
      th(colspan = 3, 'Perimeter'),
      th(colspan = 3, 'Area'),
      th(colspan = 3, 'Smoothness'),
      th(colspan = 3, 'Compactness'),
      th(colspan = 3, 'Concavity'),
      th(colspan = 3, 'Concave points'),
      th(colspan = 3, 'Symmetry'),
      th(colspan = 3, 'Fractal dimension')
    ),
    tr(
      lapply(rep(c('Mean', 'SE', 'Worst'), 10), th)
    )
  )
))

df <- data.frame(wdbc$id, wdbc$diagnosis,
           wdbc[,3], wdbc[,13], wdbc[,23],
           wdbc[,4], wdbc[,14], wdbc[,24],
           wdbc[,5], wdbc[,15], wdbc[,25],
           wdbc[,6], wdbc[,16], wdbc[,26],
           wdbc[,7], wdbc[,17], wdbc[,27],
           wdbc[,8], wdbc[,18], wdbc[,28],
           wdbc[,9], wdbc[,19], wdbc[,29],
           wdbc[,10], wdbc[,20], wdbc[,30],
           wdbc[,11], wdbc[,21], wdbc[,31],
           wdbc[,12], wdbc[,22], wdbc[,32])

DT::datatable(df, container = sketch, rownames = FALSE, options = list(scrollY = '350px', scrollX = 'true', paging = FALSE, dom = 'tp'),
              caption = 'Tableau 1 : jeu de données')

```

Les 10 variables mesurées sur les noyaux des cellules sont :

1. **Radius** : le rayon du noyau, qui est la moyenne des distances entre le centre du noyau et des points sur le périmètre
2. **Texture** : ecart-ype des valeurs des echelles de gris
3. **Perimeter** : le périmètre du noyau
6. **Area** : l'aire du noyau
7. **Smoothness** : la variation locale des longueurs du rayon
8. **Compactness**, compacité : perimeter^2 / area - 1
9. **Concavity**, concavité : sévérité des portions concaves du contour
10. **Concave points** : nombre de portions concaves du contour
11. **Symmetry** : la symétrie du noyau
12. **Fractal dimension** : "coastline approximation" - 1

Chaque échantillon a un identifiant et un diagnostic associé à la tumeur (maligne, M ; ou bénin, B). Il y a `r (wdbc$diagnosis %>% table)["B"]` tumeurs bénines (`r round((wdbc$diagnosis %>% table)["B"]*100/nrow(wdbc),2)` %) et `r (wdbc$diagnosis %>% table)["M"]` (`r round((wdbc$diagnosis %>% table)["M"]*100/nrow(wdbc),2)` %) tumeurs malignes.

Le tableau suivant résume quelques paramètres statistiques pour chaque variables :

```{r table_desc_2}
desctable(wdbc[,-1], stats = list("N"       = length,
                             "%/Mean"  = is.factor ~ percent | (is.normal ~ mean),
                             "sd"      = is.normal ~ sd,
                             "Minimum" = min,
                             "Med"     = is.normal ~ NA | median,
                             "Maximum" = max,
                             "IQR"     = is.normal ~ NA | IQR)) %>%
  datatable(options = list(dom = 't', paging = FALSE, scrollY = '350px', scrollX = 'true'),
            caption = 'Tableau 2 : paramètres statistiques pour chaque variable.')
```

La densité de répartition des valeurs de chaque variables est raportée dans les graphiques suivants.

```{r fct_draw_g, include=FALSE}
draw_g <- function(value = "radius_mean") {
  ggplot(data = wdbc) +
    aes_string(x = value, fill = "diagnosis") +
    geom_density(adjust = 1) +
    facet_wrap(vars(diagnosis)) +
    theme_minimal() +
    theme(legend.position = 'none',
          axis.title.y = element_blank(), axis.text.y = element_blank())
}
```


```{r var_graph_mean, fig.cap='Graphique 1 : répartition des moyennes pour chaque variable'}
lapply(colnames_mean, draw_g) %>% plot_grid(plotlist = .)
```

***

```{r var_graph_se, fig.cap='Graphique 2 : répartition des erreurs standard pour chaque variable'}
lapply(colnames_se, draw_g) %>% plot_grid(plotlist = .)
```

***

```{r var_graph_worst, fig.cap='Graphique 3 : répartition des pires valeurs pour chaque variable'}
lapply(colnames_worst, draw_g) %>% plot_grid(plotlist = .)
```

Diagramme de corrélation des valeurs moyennes :

```{r}
corrplot(cor(wdbc2_mean), type="upper", method="number", order="hclust", 
          col=brewer.pal(n=8, name="RdYlBu"), diag=FALSE)
corrplot(cor(wdbc2_worst), type="upper", method="number", order="hclust", 
          col=brewer.pal(n=8, name="RdYlBu"), diag=FALSE)
corrplot(cor(wdbc2_se), type="upper", method="number", order="hclust", 
          col=brewer.pal(n=8, name="RdYlBu"), diag=FALSE)

```

K-means :

```{r}
# (rappel : wdbc2, c'est wdbc avec les diagnostics numériques)

set.seed(1)
ntest <- sample(1:569, 114, replace=FALSE)
test_set <- wdbc2[ntest,]
train_set <- wdbc2[-ntest,]

data_kmeans <- wdbc
wdbc3_scaled <- wdbc2[, c(-1, -2)] %>% apply(2, FUN=scale) %>% as.data.frame
nbclusters <- NbClust(wdbc3_scaled, method="kmeans")
wdbc4 <- wdbc3 %>% mutate(cluster = nbclusters$Best.partition)
table(wdbc4$cluster, wdbc2$diagnosis)
table(wdbc4$cluster)
table(wdbc$diagnosis)
fviz_cluster(object = kmeans_cluster, data=wdbc2)




```



```{r}


```

